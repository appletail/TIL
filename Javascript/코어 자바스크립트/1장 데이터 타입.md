# 01 데이터 타입의 종류
---
![[Pasted image 20240102151020.png]]

# 02 데이터 타입에 관한 배경지식
---
## 1-2-1 메모리와 데이터
- **비트**
    0과 1 표현 가능
- **바이트**
    - 비트 단위로 위치확인하는 것은 비효율적이므로 적정한 공간을 묶어 찾기 쉽게 하였음
    - 8비트로 구성되어 있음
- 자바나 C/C++은 메모지 용량이 부족했던 시절에 나왔기 때문에 short, int 등 타입이 세분화 되어있어 형변환에 신경써야했음
- 자바스크립트는 메모리 용량이 커졌을 때 나왔기 때문에 정수형인지 부동소수형인지 구분하지않고 64비트(8바이트)를 확보함
- 모든 데이터는 메모리 주솟값(memory address)을 통해 서로 구분하고 연결할 수 있음

## 1-2-2 식별자와 변수
- **변수(variable)**
    - 변할 수 있는 무언가
    - 변경 가능한 데이터가 담길 수 있는 공간 또는 그릇
- **식별자(identifier)**
    - 변수명
    - 어떤 데이터를 식별하는 데 사용하는 이름

# 03 변수 선언과 데이터 할당
---
## 1-3-1 변수 선언
```jsx
var a;
```
- 임의의 비어있는 메모리 공간에 식별자 a를 지정하는 것

## 1-3-2 데이터 할당
```js
var a;          // 변수 a 선언
a = 'abc';      // 변수 a에 데이터 할당

var a = 'abc';  // 변수 선언과 할당을 한 문장으로 표현
```
![[Pasted image 20240102151623.png]]
```js
var a;
a = 'abc';

var a = 'abc';
a = 'abcdef';
```
![[Pasted image 20240102151637.png]]

# 04 기본형 데이터와 참조형 데이터
---
## 1-4-1 불변값
불변값과 상수는 다른 개념이다.

- **상수(constant)**
    - 변수에서 한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 없는 것
- **불변값**
    - string, number, boolean, null, undefined, Symbol과 같은 기본형 데이터가 저장되어있는 메모리를 바꿀 수 없는 것
    
```jsx
var a = 'abc';
a = a + 'def';
>> 'abcdef'
```
위 예시의 경우 컴퓨터는 ‘abc’를 ‘abcdef’로 바꾸는 것이 아닌 ‘abc’와 별개로 ‘abcdef’를 만든다. 그리고 그 주소값을 변수 a에 저장한다.

한 번 만들어진 불변값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않는다.

## 1-4-2 가변값
- **참조형 데이터의 할당**
```jsx
var obj1 = {
	a: 1,
	b: 'bbb'
};
```
![[Pasted image 20240102152320.png]]
![[Pasted image 20240102152336.png]]

- **참조형 데이터의 프로퍼티 재할당**
```jsx
var obj1 = {
	a: 1,
	b: 'bbb'
};
obj1.a = 2;
```
![[Pasted image 20240102152724.png]]
1. 데이터 영역에서 숫자 2 검색
2. 검색 결과가 없으므로 빈공간인 @5005에 저장하고 이 주소를 @7103에 저장

- **객체 자체를 재할당하는 경우**
```jsx
var obj = {
	x: 3,
	arr: [ 3, 4, 5 ]
};

obj.arr = 'str';
```
![[Pasted image 20240102152800.png]]

## 1-4-3 변수 복사 비교
- **변수 복사**
```jsx
var a = 10;
var b = a;

var obj1 = { c: 10, d: 'ddd' };
var obj2 = obj1;
```
![[Pasted image 20240102152918.png]]
- **var b에 a를 복사**
    1. @1002를 확보하고 식별자를 b로 지정
    2. 식별자 a를 검색해 @1001에 저장된 값인 @5001을 @1002에 대입
- **var obj2에 obj1을 복사**
    1. @1004를 확보하고 식별자를 obj2로 지정
    2. 식별자 a를 검색해 @1003에 저장된 값인 @5002을 @1004에 대입

- **복사 이후 객체의 프로퍼티 변경**
```jsx
var a = 10;
var b = a;
var obj1 = { c: 10, d: 'ddd' };
var obj2 = obj1;

b = 15;
obj2.c = 20;
```
![[Pasted image 20240102153029.png]]
- **b 변경**
    1. 15가 없으므로 @5004에 15를 저장
    2. 식별자 b를 검색해 @5004를 @1002에 대입
- **obj2.c 변경**
    1. 20이 없으므로 @5005에 20을 저장
    2. 식별자 obj2 검색 (@1004)
    3. obj2(@1004)의 값인 @5002로 이동
    4. @5002가 가리키는 변수 영역에서 c를 검색(@7103)
    5. @7103에 @5005대입

- **객체 자체를 변경**
```jsx
var a = 10;
var b = a;
var obj1 = { c: 10, d: 'ddd' };
var obj2 = obj1;

b = 15;
obj2 = { c: 20, d: 'ddd' };
```
![[Pasted image 20240102153154.png]]
새로운 공간(@5006)에 새 객체(@8204 ~ ?)가 저장되고 그 주소(@5006)를 obj2(@1004)에 대입

즉, 참조형 데이터가 ‘가변값’이라고 설명할 때의 ‘가변’은 참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립한다.

# 05 불변 객체
---
## 1-5-1 불변 객체를 만드는 간단한 방법
참조형 데이터의 ‘가변’은 내부 프로퍼티를 변경할 때만 성립한다. 새로운 데이터를 할당하고자 하면 기본형 데이터와 마찬가지로 **기존 데이터는 변하지 않는다.** 그러므로 내부 프로퍼티를 변경할 필요가 있을 때마다 매번 새로운 객체를 만들어 재할당한다면 객체역시 불변성을 확보할 수 있다.

- **불변 객체가 필요한 경우**
![[Pasted image 20240102153526.png]]
기존의 객체를 가져와 새로운 값을 할당하여 다른 객체를 만들어내야하는 경우 불변성을 유지하지 않으면 새로운 객체의 값을 바꿨을 때 기존 객체의 값 또한 바뀌는 문제가 발생한다.

- **객체의 가변성에 따른 문제점의 해결 방법**
    대상 객체에 정보가 많을수록, 변경해야 할 정보가 많을수록 사용자가 입력하는 수고가 늘 것이다.

1. 하드코딩
	![[Pasted image 20240102153716.png]]

2. 얕은 복사
	![[Pasted image 20240102153746.png]]
	대상 객체의 프로퍼티 개수에 상관없이 모든 프로퍼티를 복사하는 함수이다. 하지만 바로 아래단계 프로퍼티만 복사(얕은 복사)하는 한계가 있다. 즉, 중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사한다.

3. 라이브러리 사용
	immutable.js, baobab.js 등의 라이브러리는 그 자체에서 불변성을 지닌 별도의 데이터 타입과 그에 따른 메서드를 제공한다.

## 1-5-2 얕은 복사와 깊은 복사
- 얕은 복사(shallow copy): 바로 아래 단계의 값만 복사하는 방법
- 깊은 복사(deep copy): 내부의 모든 값을 하나하나 찾아서 전부 복사하는 방법

- **깊은 복사를 하는 방법**
객체의 프로퍼티 중에서 그 값이 **기본형 데이터일 경우에는 그대로 복사**하면 되지만 **참조형 데이터는 다시 그 내부의 프로퍼티들을 복사**한다. 이 과정을 참조형 데이터가 있을 때마다 재귀적으로 수행하면 된다.
![[Pasted image 20240102154230.png]]
*3번째 줄에서 target !== null 조건을 덧붙인 이유는 typeof 명령어가 null에 대해서도 ‘object’를 반환하기 때문이다(자바스크립트 자체의 버그)

- **JSON객체를 이용해 깊은 복사를 하는 방법**
```jsx
var copyObjectViaJSON = function (target) {
	return JSON.parse(JSON.stringify(target));
}
var obj = {
	a: 1,
	b: {
		c: null,
		d: [1, 2],
		func1: function () { console.log(3); }
	},
	func2: function () { console.log(4); }
};
var obj2 = copyObjectViaJSON(obj);

obj2.a = 3;
obj2.b.c = 4;
obj.b.d[1] = 3;

console.log(obj);  // { a: 1, b: { c: null, d: [1, 3], func1: f() }, func2: f() }
console.log(obj2); // { a: 3, b: { c: 4,    d: [1, 2] } }
```
객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾸는 방법이다. 다만 JSON으로 변경할 수 없는 프로퍼티들은 모두 무시한다. 그러므로 순수한 정보만 다룰 때 활용하기 좋은 방법이다.

# 06 undefined와 null
---
undefined와 null 모두 ‘없음’을 나타내는 값이지만 미세하게 다르고, 사용하는 목적 또한 다르다.

### undefined
자바스크립트 엔진은 사용자가 값을 지정할 것이라고 예상되는 상황임에도 실제로는 그렇게 하지 않았을 때 undefined를 반환한다.
![[Pasted image 20240102160055.png]]

이 세개 중 [1] 값을 대입하지 않은 경우에 대해 배열의 경우에는 조금 특이한 동작을 한다.
![[Pasted image 20240102160152.png]]
이처럼 ‘비어있는 요소’와 ‘undefined를 할당한 요소’는 출력 결과부터 다르다. ‘비어있는 요소’는 순와 관련된 많은 배열 메서드들의 순회 대상에서 제외된다.
![[Pasted image 20240102160328.png]]
이는 ‘배열도 객체’이므로 발생하는 현상이다. 존재하지 않는 프로퍼티에 대해서는 순회할 수 없는 것이 당연하다. 배열은 인덱스에 값을 지정할 때 공간을 확보하고, 인덱스를 이름으로 지정하고, 데이터의 주솟값을 저장하는 등의 동작을 한다. 즉, 값이 지정되지 않은 인덱스는 ‘아직은 존재하지 않는 프로퍼티’에 지나지 않는다.

- **사용자가 명시적으로 지정한 undefined와 자바스크립트가 반환하는 undefined의 차이**
    - 사용자가 명시적으로 지정한 undefined: 그 자체로 하나의 값이라서 프로퍼티나 배열의 요소는 고유의 키값(프로퍼티 이름)이 실존하게 되고, 순회의 대상이 된다.
    - 자바스크립트가 반환하는 undefined: 해당 프로퍼티 내지 배열의 키값(인덱스) 자체가 존재하지 않음을 나타내는 문자 그대로의 의미이다.

이러한 혼란을 피하기 위해서는 ‘없음’을 명시적으로 나타내야할 때 undefined가 아닌 null을 사용해야한다.

### null
‘비어있음’을 명시적을 나타내기 위해 만든 데이터 타입이다.

null을 사용할 때는 typeof null이 object라는 점을 주의해야한다. 이는 자바스크립트 자체의 버그로 어떤 변수의 값이 null인지 여부를 판별하기 위해서는 typeof 대신 다른 방식으로 접근해야한다.

```jsx
var n = null;
console.log(typeof n);            // object

console.log(n == undefined);      // true
console.log(n == null);           // true

console.log(n === undefined);     // false
console.log(n === null);          // true
```
*undefined와 null의 비교

동등 연산자(equality operator)(\==)로 비교할 경우 null과 undefined는 서로 같다고 판단한다. 따라서 어떤 변수가 실제로 null인지 아니면 undefined인지 확인하기 위해서는 일치 연산자(identity operator)(\=\==)를 써야만 정확히 판별할 수 있다.

# 07 정리
---
1. 자바스크립트의 데이터 타입에는 크게 **기본형**과 **참조형**이 있다.
2. **기본형**은 **불변값**이고 **참조형**은 **가변값**이다.
3. **변수**는 변경 가능한 데이터가 담길 수 있는 **공간**이고, **식별자**는 그 **변수의 이름**을 말한다.
4. 변수 선언시 동작과정
    1. 메모리의 빈 공간에 식별자 저장
    2. 그 공간에 자동으로 undefined 할당
    3. 기본형 데이터를 할당하는 경우
        1. 별도의 공간에 데이터를 저장
        2. 그 공간의 주소를 변수의 값 영역에 할당
    4. 참조형 데이터를 할당하는 경우
        1. 참조형 데이터 내부 프로퍼티들을 위한 변수 영역을 별도로 확보
        2. 확보된 주소를 변수에 연결
        3. 앞서 확보한 변수 영역에 각 프로퍼티의 식별자를 저장
        4. 각 데이터를 별도의 공간에 저장
        5. 그 공간의 주소를 식별자들과 매칭
5. 할당 과정에서 기본형과 차이가 생긴 이유는 참조형 데이터가 여러 개의 프로퍼티(변수)를 모은 '**그룹**'이기 때문이다.
6. 참조형 데이터를 불변값으로 사용하는 방법
    1. 내부 프로퍼티들을 일일이 복사(깊은 복사)
    2. 라이브러리를 사용
    3. 불변 객체는 최근 자바스크립트 진영에서 가장 중요한 개념 중 하나
7. undefined와 null은 모두 ‘없음’을 나타냄
8. **undefined**는 어떤 변수에 **값이 존재하지 않을 경우**를 의미한다.
9. **null**은 사용자가 **명시적**으로 ‘없음’을 표현하기 위해 대입한 값이다.
10. 사용자가 ‘없음’을 표현하기 위해 명시적으로 undefined를 대입하는 것은 지양하는 것이 좋다.
